/*
SQLyog Ultimate v12.09 (64 bit)
MySQL - 8.0.11 : Database - ssmblg
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`ssmblg` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */;

/*Table structure for table `blog` */

CREATE TABLE `blog` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `title` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '标题',
  `markdown` longtext NOT NULL COMMENT '内容',
  `html` longtext NOT NULL COMMENT 'html的网页',
  `data` varchar(32) NOT NULL COMMENT '日期',
  `lab_id` int(11) DEFAULT NULL COMMENT '分类',
  `mg_state` double NOT NULL DEFAULT '1' COMMENT '状态',
  PRIMARY KEY (`id`),
  KEY `lab` (`lab_id`),
  CONSTRAINT `blog_ibfk_1` FOREIGN KEY (`lab_id`) REFERENCES `lab` (`labid`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `blog` */

insert  into `blog`(`id`,`title`,`markdown`,`html`,`data`,`lab_id`,`mg_state`) values (1,'Vue中的虚拟Dom','1， 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。\n\n2，应尽量避免在 where 子句中对字段进行 null 值判断，创建表时NULL是默认值，但大多数时候应该使用NOT NULL，或者使用一个特殊的值，如0，-1作为默 认值。\n\n3，应尽量避免在 where 子句中使用!=或<>操作符， MySQL只有对以下操作符才使用索引：<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE。\n\n4，应尽量避免在 where 子句中使用 or 来连接条件， 否则将导致引擎放弃使用索引而进行全表扫描， 可以 使用UNION合并查询：\n\nselect id from t where num=10 union all select id from t where num=20\n5，in 和 not in 也要慎用，否则会导致全表扫描，对于连续的数值，能用 between 就不要用 in 了：\n\nSelect id from t where num between 1 and 3\n6，下面的查询也将导致全表扫描：\n\nselect id from t where name like \'%abc%\'\n或者\n\nselect id from t where name like \'%abc\'\n若要提高效率，可以考虑全文检索。而\n\nselect id from t where name like \'abc%\'\n才用到索引\n\n7， 如果在 where 子句中使用参数，也会导致全表扫描。\n\n8，应尽量避免在 where 子句中对字段进行表达式操作，应尽量避免在where子句中对字段进行函数操作\n\n9,很多时候用 exists 代替 in 是一个好的选择：\n\nselect num from a where num in(select num from b);\n用下面的语句替换：\n\nselect num from a where exists(select 1 from b where num=a.num)\n10,索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。\n一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。\n\n11,应尽可能的避免更新 clustered 索引数据列， 因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。\n若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。\n\n12，尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。\n\n13，尽可能的使用 varchar/nvarchar 代替 char/nchar ， 因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。\n\n14，最好不要使用”“返回所有：\n\nselect from t\n用具体的字段列表代替“*”，不要返回用不到的任何字段。\n\n15，尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。\n\n16，使用表的别名(Alias)：\n当在SQL语句中连接多个表时,请使用表的别名并把别名前缀于每个Column上.\n这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误。\n\n17，使用“临时表”暂存中间结果\n简化SQL语句的重要方法就是采用临时表暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。\n\n18，一些SQL查询语句应加上nolock，读、写是会相互阻塞的，为了提高并发性能，对于一些查询，可以加上nolock，这样读的时候可以允许写，但缺点是可能读到未提交的脏数据。\n使用 nolock有3条原则。\n查询的结果用于“插、删、改”的不能加nolock ！\n查询的表属于频繁发生页分裂的，慎用nolock ！\n使用临时表一样可以保存“数据前影”，起到类似Oracle的undo表空间的功能，能采用临时表提高并发性能的，\n不要用nolock 。\n\n19，常见的简化规则如下：\n不要有超过5个以上的表连接（JOIN），考虑使用临时表或表变量存放中间结果。\n少用子查询，视图嵌套不要过深,一般视图嵌套不要超过2个为宜。\n\n20，将需要查询的结果预先计算好放在表中，查询的时候再Select。\n这在SQL7.0以前是最重要的手段。\n例如医院的住院费计算。\n','<div class=blogDetail><p>1， 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>\n<p>2，应尽量避免在 where 子句中对字段进行 null 值判断，创建表时NULL是默认值，但大多数时候应该使用NOT NULL，或者使用一个特殊的值，如0，-1作为默 认值。</p>\n<p>3，应尽量避免在 where 子句中使用!=或&lt;&gt;操作符， MySQL只有对以下操作符才使用索引：&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的LIKE。</p>\n<p>4，应尽量避免在 where 子句中使用 or 来连接条件， 否则将导致引擎放弃使用索引而进行全表扫描， 可以 使用UNION合并查询：</p>\n<p>select id from t where num=10 union all select id from t where num=20<br />\n5，in 和 not in 也要慎用，否则会导致全表扫描，对于连续的数值，能用 between 就不要用 in 了：</p>\n<p>Select id from t where num between 1 and 3<br />\n6，下面的查询也将导致全表扫描：</p>\n<p>select id from t where name like ‘%abc%’<br />\n或者</p>\n<p>select id from t where name like ‘%abc’<br />\n若要提高效率，可以考虑全文检索。而</p>\n<p>select id from t where name like ‘abc%’<br />\n才用到索引</p>\n<p>7， 如果在 where 子句中使用参数，也会导致全表扫描。</p>\n<p>8，应尽量避免在 where 子句中对字段进行表达式操作，应尽量避免在where子句中对字段进行函数操作</p>\n<p>9,很多时候用 exists 代替 in 是一个好的选择：</p>\n<p>select num from a where num in(select num from b);<br />\n用下面的语句替换：</p>\n<p>select num from a where exists(select 1 from b where num=a.num)<br />\n10,索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。<br />\n一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p>\n<p>11,应尽可能的避免更新 clustered 索引数据列， 因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。<br />\n若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p>\n<p>12，尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。</p>\n<p>13，尽可能的使用 varchar/nvarchar 代替 char/nchar ， 因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>\n<p>14，最好不要使用”“返回所有：</p>\n<p>select from t<br />\n用具体的字段列表代替“*”，不要返回用不到的任何字段。</p>\n<p>15，尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>\n<p>16，使用表的别名(Alias)：<br />\n当在SQL语句中连接多个表时,请使用表的别名并把别名前缀于每个Column上.<br />\n这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误。</p>\n<p>17，使用“临时表”暂存中间结果<br />\n简化SQL语句的重要方法就是采用临时表暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。</p>\n<p>18，一些SQL查询语句应加上nolock，读、写是会相互阻塞的，为了提高并发性能，对于一些查询，可以加上nolock，这样读的时候可以允许写，但缺点是可能读到未提交的脏数据。<br />\n使用 nolock有3条原则。<br />\n查询的结果用于“插、删、改”的不能加nolock ！<br />\n查询的表属于频繁发生页分裂的，慎用nolock ！<br />\n使用临时表一样可以保存“数据前影”，起到类似Oracle的undo表空间的功能，能采用临时表提高并发性能的，<br />\n不要用nolock 。</p>\n<p>19，常见的简化规则如下：<br />\n不要有超过5个以上的表连接（JOIN），考虑使用临时表或表变量存放中间结果。<br />\n少用子查询，视图嵌套不要过深,一般视图嵌套不要超过2个为宜。</p>\n<p>20，将需要查询的结果预先计算好放在表中，查询的时候再Select。<br />\n这在SQL7.0以前是最重要的手段。<br />\n例如医院的住院费计算。</p>\n</div>','2020-06-25 23:57',2,1);
insert  into `blog`(`id`,`title`,`markdown`,`html`,`data`,`lab_id`,`mg_state`) values (2,'MySQL数据库字典导出功能','由于项目需求会经常发生变化，导致数据库数据表可能结构上发生变化，这样可能会导致数据库字段说明文档跟数据库字段不一致问题，\n\n同步更新文档又浪费时间，还不如直接将数据库导出成数据库字典不就完了，简单不费时。\n\n主要数据库字典生成的SQL语句：\n\n\n主要的程序代码是用PHP完成的，具体如下：\n\n创建PDO连接MySQL实例：\n\n```language\ntry {\n    $this->conn = new PDO(\"mysql:host={$this->host};port={$this->port};dbname=information_schema\", $this->user, $this->passwd, $this->driver_options);\n    $this->conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n}\ncatch(PDOException $e){\n    echo $e->getMessage();\n}\n```\n利用PDO预处理查询数据：\n```language\n$result = $this->conn->prepare($sql);//准备查询语句\n$result->execute();//执行查询语句，并返回结果集\n$this->data = $result->fetchAll(PDO::FETCH_ASSOC);//获取结果集中的所有数据\n```\n导出生成数据库字典word文档：\n```language\nif (strpos($_SERVER[\"HTTP_USER_AGENT\"], \'MSIE\')) {  \n    header(\"Content-Disposition: attachment; filename={$this->database}数据字典.doc\");  \n}else if (strpos($_SERVER[\"HTTP_USER_AGENT\"], \'Firefox\')) {  \n    header(\"Content-Disposition: attachment; filename={$this->database}数据字典.doc\");  \n} else {  \n    header(\"Content-Disposition: attachment; filename={$this->database}数据字典.doc\");  \n}  \nheader(\"Pragma:no-cache\"); //不能被浏览器缓存 \nheader(\"Expires:0\");  //页面从浏览器高速缓存到期的时间分钟数，设定expires属性为0，将使对一页面的新的请求从服务器产生\nob_end_flush();//输出全部内容到浏览器\n```\n','<p>由于项目需求会经常发生变化，导致数据库数据表可能结构上发生变化，这样可能会导致数据库字段说明文档跟数据库字段不一致问题，</p>\n<p>同步更新文档又浪费时间，还不如直接将数据库导出成数据库字典不就完了，简单不费时。</p>\n<p>主要数据库字典生成的SQL语句：</p>\n<p>主要的程序代码是用PHP完成的，具体如下：</p>\n<p>创建PDO连接MySQL实例：</p>\n<pre><code class=\"lang-language\">try {\n    $this-&gt;conn = new PDO(&quot;mysql:host={$this-&gt;host};port={$this-&gt;port};dbname=information_schema&quot;, $this-&gt;user, $this-&gt;passwd, $this-&gt;driver_options);\n    $this-&gt;conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n}\ncatch(PDOException $e){\n    echo $e-&gt;getMessage();\n}\n</code></pre>\n<p>利用PDO预处理查询数据：</p>\n<pre><code class=\"lang-language\">$result = $this-&gt;conn-&gt;prepare($sql);//准备查询语句\n$result-&gt;execute();//执行查询语句，并返回结果集\n$this-&gt;data = $result-&gt;fetchAll(PDO::FETCH_ASSOC);//获取结果集中的所有数据\n</code></pre>\n<p>导出生成数据库字典word文档：</p>\n<pre><code class=\"lang-language\">if (strpos($_SERVER[&quot;HTTP_USER_AGENT&quot;], \'MSIE\')) {  \n    header(&quot;Content-Disposition: attachment; filename={$this-&gt;database}数据字典.doc&quot;);  \n}else if (strpos($_SERVER[&quot;HTTP_USER_AGENT&quot;], \'Firefox\')) {  \n    header(&quot;Content-Disposition: attachment; filename={$this-&gt;database}数据字典.doc&quot;);  \n} else {  \n    header(&quot;Content-Disposition: attachment; filename={$this-&gt;database}数据字典.doc&quot;);  \n}  \nheader(&quot;Pragma:no-cache&quot;); //不能被浏览器缓存 \nheader(&quot;Expires:0&quot;);  //页面从浏览器高速缓存到期的时间分钟数，设定expires属性为0，将使对一页面的新的请求从服务器产生\nob_end_flush();//输出全部内容到浏览器\n</code></pre>\n','2020-06-17',4,1);
insert  into `blog`(`id`,`title`,`markdown`,`html`,`data`,`lab_id`,`mg_state`) values (3,'JavaScript常见算法排序之冒泡排序',' #### 1、算法原理\n冒泡排序是一种简单的排序算法。 它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。\n\n走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。\n\n#### 2、算法流程\n（1）比较相邻的元素。 如果第一个比第二个大，就交换它们两个。\n\n（2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。 在这一点，最后的元素应该会是最大的数。\n\n（3）针对所有的元素重复以上的步骤，除了最后一个。\n\n（4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较\n\n#### 3、实例分析\n以数组 arr = [5, 1, 4, 2, 8] 为例说明：\n\n```第一次外循环\n( 5 1 4 2 8 ) → ( 1 5 4 2 8 )， 5 > 1 交换位置\n( 1 5 4 2 8 ) → ( 1 4 5 2 8 )， 5 > 4 交换位置\n( 1 4 5 2 8 ) → ( 1 4 2 5 8 )， 5 > 2 交换位置\n( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 5 < 8 位置不变\n第二次外循环（除开最后一个元素8，对剩余的序列）\n\n( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 1 < 4 位置不变\n( 1 4 2 5 8 ) → ( 1 2 4 5 8 )， 4 > 2 交换位置\n( 1 2 4 5 8 ) → ( 1 2 4 5 8 )， 4 < 5 位置不变\n第三次外循环（除开已经排序好的最后两个元素，可以注意到上面的数组其实已经排序完成，但是程序本身并不知道，\n\n所以还要进行后续的循环，直到剩余的序列为 1）\n\n( 1 2 4 5 8 ) → ( 1 2 4 5 8 )\n( 1 2 4 5 8 ) → ( 1 2 4 5 8 )\n第四次外循环（最后一次）\n```\n\n\n( 1 2 4 5 8 ) → ( 1 2 4 5 8 )\n#### 4、代码实现\n```function bubbleSort(array){\n   var temp;\n   for(var i = array.length; 0 < i; i --){\n       for(var j = 0; j < i; j ++){\n           if (array[j] > array[j + 1]) {\n          temp         = array[j];\n          array[j]     = array[j + 1];\n          array[j + 1] = temp;\n      }\n       }\n    }\n    return array;\n}\n\n```\n','<div class=blogDetail><h4><a id=\"1_0\"></a>1、算法原理</h4>\n<p>冒泡排序是一种简单的排序算法。 它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。</p>\n<p>走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>\n<h4><a id=\"2_5\"></a>2、算法流程</h4>\n<p>（1）比较相邻的元素。 如果第一个比第二个大，就交换它们两个。</p>\n<p>（2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。 在这一点，最后的元素应该会是最大的数。</p>\n<p>（3）针对所有的元素重复以上的步骤，除了最后一个。</p>\n<p>（4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</p>\n<h4><a id=\"3_14\"></a>3、实例分析</h4>\n<p>以数组 arr = [5, 1, 4, 2, 8] 为例说明：</p>\n<pre><code class=\"lang-第一次外循环\">( 5 1 4 2 8 ) → ( 1 5 4 2 8 )， 5 &gt; 1 交换位置\n( 1 5 4 2 8 ) → ( 1 4 5 2 8 )， 5 &gt; 4 交换位置\n( 1 4 5 2 8 ) → ( 1 4 2 5 8 )， 5 &gt; 2 交换位置\n( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 5 &lt; 8 位置不变\n第二次外循环（除开最后一个元素8，对剩余的序列）\n\n( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 1 &lt; 4 位置不变\n( 1 4 2 5 8 ) → ( 1 2 4 5 8 )， 4 &gt; 2 交换位置\n( 1 2 4 5 8 ) → ( 1 2 4 5 8 )， 4 &lt; 5 位置不变\n第三次外循环（除开已经排序好的最后两个元素，可以注意到上面的数组其实已经排序完成，但是程序本身并不知道，\n\n所以还要进行后续的循环，直到剩余的序列为 1）\n\n( 1 2 4 5 8 ) → ( 1 2 4 5 8 )\n( 1 2 4 5 8 ) → ( 1 2 4 5 8 )\n第四次外循环（最后一次）\n</code></pre>\n<p>( 1 2 4 5 8 ) → ( 1 2 4 5 8 )</p>\n<h4><a id=\"4_38\"></a>4、代码实现</h4>\n<pre><code class=\"lang-function\">   var temp;\n   for(var i = array.length; 0 &lt; i; i --){\n       for(var j = 0; j &lt; i; j ++){\n           if (array[j] &gt; array[j + 1]) {\n          temp         = array[j];\n          array[j]     = array[j + 1];\n          array[j + 1] = temp;\n      }\n       }\n    }\n    return array;\n}\n\n</code></pre>\n</div>','2020-06-28',9,1);
insert  into `blog`(`id`,`title`,`markdown`,`html`,`data`,`lab_id`,`mg_state`) values (4,'MySQL Limit分页优化','在对大量数据查询中需要进行分页的时候，我们通常会使用Limit加上偏移量的方法实现，\n\n问题来了，在偏移量非常大的时候，例如可能是limit 10000,10这样的查询，这时MySQL需要查询10010条记录然后只返回最后的10条，\n\n前面10000条记录都被抛弃，造成效率低下。\n\n优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖查询，而不是查询所有的列，\n\n然后根据需要做一个关联操作再返回所需的列，对于偏移量很大的时候，这样做的效率会有很大提升。\n```language\nSELECT * FROM test LIMIT 900000,10; 慢\nSELECT * FROM test WHERE id >= ( SELECT id FROM test ORDER BY id LIMIT 900000,1 ) LIMIT 10 快\n```\n','<div class=blogDetail><p>在对大量数据查询中需要进行分页的时候，我们通常会使用Limit加上偏移量的方法实现，</p>\n<p>问题来了，在偏移量非常大的时候，例如可能是limit 10000,10这样的查询，这时MySQL需要查询10010条记录然后只返回最后的10条，</p>\n<p>前面10000条记录都被抛弃，造成效率低下。</p>\n<p>优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖查询，而不是查询所有的列，</p>\n<p>然后根据需要做一个关联操作再返回所需的列，对于偏移量很大的时候，这样做的效率会有很大提升。</p>\n<pre><code class=\"lang-language\">SELECT * FROM test LIMIT 900000,10; 慢\nSELECT * FROM test WHERE id &gt;= ( SELECT id FROM test ORDER BY id LIMIT 900000,1 ) LIMIT 10 快\n</code></pre>\n</div>','2020-06-18',4,1);
insert  into `blog`(`id`,`title`,`markdown`,`html`,`data`,`lab_id`,`mg_state`) values (5,'Redis常见使用场景','Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。本篇文章，主要介绍利用PHP使用Redis，主要的应用场景。\n##### 1、字符串缓存\n```language\n$redis->connect(\'127.0.0.1\', 6379);\n$cacheKey  = \'cache1\';\n//SET 应用\n$arrCacheData = [\'name\'=>\'job\',\'sex\'=>\'男\',\'age\'=>\'30\'];\n$redis->set($cacheKey, json_encode($arrCacheData));\n$redis->expire($cacheKey, 30);  # 设置30秒后过期\n$json_data = $redis->get($cacheKey);\n$data = json_decode($json_data， true);\nprint_r($data[\'age\']); //输出数据\n//HSET 应用\n$arrWebSite = [\n    \'a\'=>[\'aa\',\'1234\'],\n    \'b\'=>[\'bb\',\'56789\'],\n];\n$redis->hSet($cacheKey, \'a\', json_encode($arrWebSite[\'a\']));\n$json_data = $redis->hGet($cacheKey, \'a\');\n$data = json_decode($json_data);\nprint_r($data); //输出数据复制代码\n```\n##### 2、队列\n\n```language\n$redis->connect(\'127.0.0.1\', 6379);\n$queuekey  = \'queue\';\n//进队列\n$redis->rpush($queuekey, json_encode([\'uid\' => 1,\'name\' => \'Job\']));\n$redis->rpush($queuekey, json_encode([\'uid\' => 2,\'name\' => \'Tom\']));\n$redis->rpush($queuekey, json_encode([\'uid\' => 3,\'name\' => \'John\']));\necho \"---- 进队列成功 ---- <br/>\";\n//查看队列\n$strCount = $redis->lrange($queuekey, 0, -1);\necho \"当前队列数据为： <br />\";\nprint_r($strCount);\n//出队列\n$redis->lpop($queuekey);\necho \"<br/> ---- 出队列成功 ---- <br />\";\n//查看队列\n$strCount = $redis->lrange($queuekey, 0, -1);\necho \"当前队列数据为： <br />\";\nprint_r($strCount);\n```\n##### 3、发布订阅\n```language\n//以下是 pub.php 文件的内容 cli下运行\nini_set(\'default_socket_timeout\', -1);\n$redis->connect(\'127.0.0.1\', 6379);\n$strChannel = \'test_channel\';\n//发布\n$redis->publish($strChannel, \"来自{$strChannel}频道的推送\");\necho \"---- {$strChannel} ---- 频道消息推送成功～ <br/>\";\n$redis->close();\n```\n\n\n\n','<div class=blogDetail><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。本篇文章，主要介绍利用PHP使用Redis，主要的应用场景。</p>\n<h5><a id=\"1_1\"></a>1、字符串缓存</h5>\n<pre><code class=\"lang-language\">$redis-&gt;connect(\'127.0.0.1\', 6379);\n$cacheKey  = \'cache1\';\n//SET 应用\n$arrCacheData = [\'name\'=&gt;\'job\',\'sex\'=&gt;\'男\',\'age\'=&gt;\'30\'];\n$redis-&gt;set($cacheKey, json_encode($arrCacheData));\n$redis-&gt;expire($cacheKey, 30);  # 设置30秒后过期\n$json_data = $redis-&gt;get($cacheKey);\n$data = json_decode($json_data， true);\nprint_r($data[\'age\']); //输出数据\n//HSET 应用\n$arrWebSite = [\n    \'a\'=&gt;[\'aa\',\'1234\'],\n    \'b\'=&gt;[\'bb\',\'56789\'],\n];\n$redis-&gt;hSet($cacheKey, \'a\', json_encode($arrWebSite[\'a\']));\n$json_data = $redis-&gt;hGet($cacheKey, \'a\');\n$data = json_decode($json_data);\nprint_r($data); //输出数据复制代码\n</code></pre>\n<h5><a id=\"2_22\"></a>2、队列</h5>\n<pre><code class=\"lang-language\">$redis-&gt;connect(\'127.0.0.1\', 6379);\n$queuekey  = \'queue\';\n//进队列\n$redis-&gt;rpush($queuekey, json_encode([\'uid\' =&gt; 1,\'name\' =&gt; \'Job\']));\n$redis-&gt;rpush($queuekey, json_encode([\'uid\' =&gt; 2,\'name\' =&gt; \'Tom\']));\n$redis-&gt;rpush($queuekey, json_encode([\'uid\' =&gt; 3,\'name\' =&gt; \'John\']));\necho &quot;---- 进队列成功 ---- &lt;br/&gt;&quot;;\n//查看队列\n$strCount = $redis-&gt;lrange($queuekey, 0, -1);\necho &quot;当前队列数据为： &lt;br /&gt;&quot;;\nprint_r($strCount);\n//出队列\n$redis-&gt;lpop($queuekey);\necho &quot;&lt;br/&gt; ---- 出队列成功 ---- &lt;br /&gt;&quot;;\n//查看队列\n$strCount = $redis-&gt;lrange($queuekey, 0, -1);\necho &quot;当前队列数据为： &lt;br /&gt;&quot;;\nprint_r($strCount);\n</code></pre>\n<h5><a id=\"3_44\"></a>3、发布订阅</h5>\n<pre><code class=\"lang-language\">//以下是 pub.php 文件的内容 cli下运行\nini_set(\'default_socket_timeout\', -1);\n$redis-&gt;connect(\'127.0.0.1\', 6379);\n$strChannel = \'test_channel\';\n//发布\n$redis-&gt;publish($strChannel, &quot;来自{$strChannel}频道的推送&quot;);\necho &quot;---- {$strChannel} ---- 频道消息推送成功～ &lt;br/&gt;&quot;;\n$redis-&gt;close();\n</code></pre>\n</div>','2020-06-23',5,1);
insert  into `blog`(`id`,`title`,`markdown`,`html`,`data`,`lab_id`,`mg_state`) values (6,'一份来自前端小白的性能优化理解','#### 前言：\n一说到性能优化，大家都不约而同的想起了雅虎的军规，2-5-8原则，3秒的首屏准则等等，这些规则在开发中虽然不是强制要求的，但是为了追求页面性能的完美体验，就不得不对代码进行修改和优化。\n\n下面就与大家一同分享一下我了解的一些性能优化指标：\n\n#### 一．加载优化\n1.    减少HTTP请求：尽量减少向服务器发送的请求数，节省网络资源，所有静态资源都要放在服务器端并设置缓存，并且要尽量使用长缓存。\n\n2.    压缩代码：减少资源大小可加快网页的显示速度，对代码进行压缩，并在服务器开启Gzip\n\n3.    无阻塞：头部内联的样式和脚本会阻塞页面的渲染，样式放在头部使用link引入，脚本放在尾部并使用异步方式加载。\n\n4.    首屏加载：首屏快速显示可大大的提升用户对页面速度的感知，应尽量针对首屏的快速显示做出相应的优化。\n\n5.    按需加载：将不影响首屏的资源和当前屏幕不使用的资源放到用户需要时才加载，可大幅度提升显示速度和降低总体流量。但是按需加载会导致大量重绘，影响渲染性能。\n\n6.    预加载：大型资源页面可使用Loading，资源加载完成后再显示页面，但是加载时间过长，会造成负体验。\n\n7.    压缩图像：使用图像时选择最合适的格式和大小，然后使用工具压缩，同时在代码中进行图片懒加载。\n\n8.    减少Cookie：Cookie会影响加载速度，所以尽量减少不必要的Cookie。\n\n9.    异步加载第三方资源：第三方资源不可控，会影响页面加载，所以要异步加载第三方资源。\n\n#### 二．执行优化\n1．css写在头部，js写在尾部并异步。\n\n2．避免img、iframe等标签的src属性为空：空src会重新加载当前页面，影响速度和效率。\n\n3．尽量避免重置图像大小：多次重置图像大小会引发图像的多次重绘，影响性能。\n\n4．图像尽量避免使用DataURL：DataURL图像没有使用图像压缩算法，文件会变大，并且要解码后再渲染，加载慢耗时长。\n\n#### 三．渲染优化\n1．设置Viewport：HTML的viewport可加快页面的渲染。\n\n2．减少DOM结点：DOM结点太多会影响页面的渲染。\n\n3．尽量使用css3动画，合理使用requestAnimationFrame动画代替setTimeout。\n\n4．优化高频事件：scroll、touchmove等事件尽量使用函数防抖节流等进行限制。\n\n#### 四．样式优化\n1．避免在HTMl中书写style。\n\n2．避免css表达式：css表达式的执行需要跳出css树的渲染。\n\n3．移除css空规则：css空规则增加了css文件的大小。\n\n4．正确使用display：display会影响页面的渲染。\n\n5．不滥用float：float在渲染时计算量较大，尽量减少使用。\n\n6．不滥用WEB字体：WEB字体需要下载、解析、重绘当前页面，尽量减少使用。\n\n#### 五．脚本优化\n1．尽量减少回流和重绘。\n\n2．缓存DOM选择与计算：每次DOM选择都要计算和缓存。\n\n3．缓存.length的值：每次.length计算使用一个变量保存值。\n\n4．尽量使用事件代理：避免批量绑定事件。\n\n5．尽量使用id选择器：id选择器选择元素是最快的。\n\n##### 2-5-8原则\n在前端开发中，此规则作为一种开发指导思路，针对浏览器页面的性能优化。\n\no  用户在2秒内得到响应，会感觉页面的响应速度很快 Fast\n\no  用户在2~5秒间得到响应，会感觉页面的响应速度还行 Medium\n\no  用户在5~8秒间得到响应，会感觉页面的响应速度很慢，但还可以接受 Slow\n\no  用户在8秒后仍然无法得到响应，会感觉页面的响应速度垃圾死了(「此时会有以下四种可能」)\n\n§ 难道是网速不好，发起第二次请求 => 刷新页面\n\n§ 什么垃圾页面呀，怎么还不打开 => 离开页面，有可能转投竞争对手的网站\n\n§ 垃圾程序猿，做的是什么页面啊 => 咒骂开发此页面的程序猿\n\n§ 断网了 => 网线断了？Wi-Fi断了？信号不好？话费用完了？','<div class=blogDetail><h4><a id=\"_0\"></a>前言：</h4>\n<p>一说到性能优化，大家都不约而同的想起了雅虎的军规，2-5-8原则，3秒的首屏准则等等，这些规则在开发中虽然不是强制要求的，但是为了追求页面性能的完美体验，就不得不对代码进行修改和优化。</p>\n<p>下面就与大家一同分享一下我了解的一些性能优化指标：</p>\n<h4><a id=\"_5\"></a>一．加载优化</h4>\n<ol>\n<li>\n<p>减少HTTP请求：尽量减少向服务器发送的请求数，节省网络资源，所有静态资源都要放在服务器端并设置缓存，并且要尽量使用长缓存。</p>\n</li>\n<li>\n<p>压缩代码：减少资源大小可加快网页的显示速度，对代码进行压缩，并在服务器开启Gzip</p>\n</li>\n<li>\n<p>无阻塞：头部内联的样式和脚本会阻塞页面的渲染，样式放在头部使用link引入，脚本放在尾部并使用异步方式加载。</p>\n</li>\n<li>\n<p>首屏加载：首屏快速显示可大大的提升用户对页面速度的感知，应尽量针对首屏的快速显示做出相应的优化。</p>\n</li>\n<li>\n<p>按需加载：将不影响首屏的资源和当前屏幕不使用的资源放到用户需要时才加载，可大幅度提升显示速度和降低总体流量。但是按需加载会导致大量重绘，影响渲染性能。</p>\n</li>\n<li>\n<p>预加载：大型资源页面可使用Loading，资源加载完成后再显示页面，但是加载时间过长，会造成负体验。</p>\n</li>\n<li>\n<p>压缩图像：使用图像时选择最合适的格式和大小，然后使用工具压缩，同时在代码中进行图片懒加载。</p>\n</li>\n<li>\n<p>减少Cookie：Cookie会影响加载速度，所以尽量减少不必要的Cookie。</p>\n</li>\n<li>\n<p>异步加载第三方资源：第三方资源不可控，会影响页面加载，所以要异步加载第三方资源。</p>\n</li>\n</ol>\n<h4><a id=\"_24\"></a>二．执行优化</h4>\n<p>1．css写在头部，js写在尾部并异步。</p>\n<p>2．避免img、iframe等标签的src属性为空：空src会重新加载当前页面，影响速度和效率。</p>\n<p>3．尽量避免重置图像大小：多次重置图像大小会引发图像的多次重绘，影响性能。</p>\n<p>4．图像尽量避免使用DataURL：DataURL图像没有使用图像压缩算法，文件会变大，并且要解码后再渲染，加载慢耗时长。</p>\n<h4><a id=\"_33\"></a>三．渲染优化</h4>\n<p>1．设置Viewport：HTML的viewport可加快页面的渲染。</p>\n<p>2．减少DOM结点：DOM结点太多会影响页面的渲染。</p>\n<p>3．尽量使用css3动画，合理使用requestAnimationFrame动画代替setTimeout。</p>\n<p>4．优化高频事件：scroll、touchmove等事件尽量使用函数防抖节流等进行限制。</p>\n<h4><a id=\"_42\"></a>四．样式优化</h4>\n<p>1．避免在HTMl中书写style。</p>\n<p>2．避免css表达式：css表达式的执行需要跳出css树的渲染。</p>\n<p>3．移除css空规则：css空规则增加了css文件的大小。</p>\n<p>4．正确使用display：display会影响页面的渲染。</p>\n<p>5．不滥用float：float在渲染时计算量较大，尽量减少使用。</p>\n<p>6．不滥用WEB字体：WEB字体需要下载、解析、重绘当前页面，尽量减少使用。</p>\n<h4><a id=\"_55\"></a>五．脚本优化</h4>\n<p>1．尽量减少回流和重绘。</p>\n<p>2．缓存DOM选择与计算：每次DOM选择都要计算和缓存。</p>\n<p>3．缓存.length的值：每次.length计算使用一个变量保存值。</p>\n<p>4．尽量使用事件代理：避免批量绑定事件。</p>\n<p>5．尽量使用id选择器：id选择器选择元素是最快的。</p>\n<h5><a id=\"258_66\"></a>2-5-8原则</h5>\n<p>在前端开发中，此规则作为一种开发指导思路，针对浏览器页面的性能优化。</p>\n<p>o  用户在2秒内得到响应，会感觉页面的响应速度很快 Fast</p>\n<p>o  用户在2~5秒间得到响应，会感觉页面的响应速度还行 Medium</p>\n<p>o  用户在5~8秒间得到响应，会感觉页面的响应速度很慢，但还可以接受 Slow</p>\n<p>o  用户在8秒后仍然无法得到响应，会感觉页面的响应速度垃圾死了(「此时会有以下四种可能」)</p>\n<p>§ 难道是网速不好，发起第二次请求 =&gt; 刷新页面</p>\n<p>§ 什么垃圾页面呀，怎么还不打开 =&gt; 离开页面，有可能转投竞争对手的网站</p>\n<p>§ 垃圾程序猿，做的是什么页面啊 =&gt; 咒骂开发此页面的程序猿</p>\n<p>§ 断网了 =&gt; 网线断了？Wi-Fi断了？信号不好？话费用完了？</p>\n</div>','2020-06-27',2,0);
insert  into `blog`(`id`,`title`,`markdown`,`html`,`data`,`lab_id`,`mg_state`) values (7,'虚拟Dom','1、定义：\n虚拟DOM其实就是一棵以 JavaScript 对象( VNode 节点)作为基础的树，用对象属性来描述节点， 实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。\n\n相当于在js与DOM之间做了一个缓存，利用patch（diff算法）对比新旧虚拟DOM记录到一个对象中按需更新， 最后创建真实的DOM\n\n2、虚拟dom原理流程\n模板 ==> 渲染函数 ==> 虚拟DOM树 ==> 真实DOM\n\nvuejs通过编译将模板（template）转成渲染函数（render），执行渲染函数可以得到一个虚拟节点树\n\n在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对应的 update 来修改视图。[原文地址](https://blog.csdn.net/weixin_43924228/article/details/106586783)','<div class=blogDetail><p>1、定义：<br />\n虚拟DOM其实就是一棵以 JavaScript 对象( VNode 节点)作为基础的树，用对象属性来描述节点， 实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。</p>\n<p>相当于在js与DOM之间做了一个缓存，利用patch（diff算法）对比新旧虚拟DOM记录到一个对象中按需更新， 最后创建真实的DOM</p>\n<p>2、虚拟dom原理流程<br />\n模板 ==&gt; 渲染函数 ==&gt; 虚拟DOM树 ==&gt; 真实DOM</p>\n<p>vuejs通过编译将模板（template）转成渲染函数（render），执行渲染函数可以得到一个虚拟节点树</p>\n<p>在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对应的 update 来修改视图。<a href=\"https://blog.csdn.net/weixin_43924228/article/details/106586783\" target=\"_blank\">原文地址</a></p>\n</div>','2020-06-27',1,1);
insert  into `blog`(`id`,`title`,`markdown`,`html`,`data`,`lab_id`,`mg_state`) values (9,' id主键自增加删除后不连续的问题','在主键id删除某一条后，再次添加，删除的id不会使用，这是为了主键的唯一性，但是在程序中可能会出现问题，导致前后端不统一。\n\n解决问题的思路是：修改开始自增加的id，从而让自增加开始于你设置的值\n\n用到的方法是：alter table category auto_increment = 100\n\n100为举例值，实际值看你自己\n\n举例：在tp5中\n```language\n//先用max方法获取当前最大的id，然后加1，保存为变量\n$max_id = DB::name(\'category\') ->max(\'category_id\');\n//id+1\n$max_id++;\n//重置自动增加为当前最大值加1\nDB::execute(\"alter table category auto_increment=\".$max_id);\n```\n\n[原文链接](\n原文链接)：','<div class=blogDetail><p>在主键id删除某一条后，再次添加，删除的id不会使用，这是为了主键的唯一性，但是在程序中可能会出现问题，导致前后端不统一。</p>\n<p>解决问题的思路是：修改开始自增加的id，从而让自增加开始于你设置的值</p>\n<p>用到的方法是：alter table category auto_increment = 100</p>\n<p>100为举例值，实际值看你自己</p>\n<p>举例：在tp5中</p>\n<pre><code class=\"lang-language\">//先用max方法获取当前最大的id，然后加1，保存为变量\n$max_id = DB::name(\'category\') -&gt;max(\'category_id\');\n//id+1\n$max_id++;\n//重置自动增加为当前最大值加1\nDB::execute(&quot;alter table category auto_increment=&quot;.$max_id);\n</code></pre>\n<p><a href=\"%E5%8E%9F%E6%96%87%E9%93%BE%E6%8E%A5\" target=\"_blank\">原文链接</a>：</p>\n</div>','2020-06-20',4,0);
insert  into `blog`(`id`,`title`,`markdown`,`html`,`data`,`lab_id`,`mg_state`) values (10,'或许你不知道的12条SQL技巧','#### 一、一些常见的SQL实践\n（1）负向条件查询不能使用索引。\n\n	select * from order where status!=0 and stauts!=1\n\n	not in/not exists 都不是好习惯。\n\n可以优化为in查询：\n\n	select * from order where status in(2,3)\n\n（2）前导模糊查询不能使用索引。\n\n	select * from order where desc like \'%XX\'\n\n而非前导模糊查询则可以：\n\n	select * from order where desc like \'XX%\'\n\n（3）数据区分度不大的字段不宜使用索引。\n\n	select * from user where sex=1\n\n原因：性别只有男，女，每次过滤掉的数据很少，不宜使用索引。\n\n经验上，能过滤80%数据时就可以使用索引。对于订单状态，如果状态值很少，不宜使用索引，如果状态值很多，能够过滤大量数据，则应该建立索引。\n\n（4）在属性上进行计算不能命中索引。\n\n	select * from order where YEAR(date) < = \'2020\'\n\n即使date上建立了索引，也会全表扫描，可优化为值计算：\n\n	select * from order where date < = CURDATE()\n\n或者：\n\n	select * from order where date < = \'2020-01-01\'\n#### 二、并非周知的SQL实践\n\n（5）如果业务大部分是单条查询，使用Hash索引性能更好，例如用户中心。\n\n	select * from user where uid=?\n\n	select * from user where login_name=?\n\n原因：\n\n	B-Tree索引的时间复杂度是O(log(n))；\n\n	Hash索引的时间复杂度是O(1)。\n\n（6）允许为null的列，查询有潜在大坑。\n\n单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集。\n\n	select * from user where name != \'shenjian\'\n\n如果name允许为null，索引不存储null值，结果集中不会包含这些记录。\n\n所以，请使用not null约束以及默认值。\n\n（7）复合索引最左前缀，并不是指SQL语句的where顺序要和复合索引一致。\n\n用户中心建立了(login_name, passwd)的复合索引\n\n	select * from user where login_name=? and passwd=?\n\n	select * from user where passwd=? and login_name=?\n\n都能够命中索引。\n\n	select * from user where login_name=?\n\n也能命中索引，满足复合索引最左前缀。\n\n	select * from user where passwd=?\n\n不能命中索引，不满足复合索引最左前缀。\n\n（8）使用ENUM而不是字符串。\n\nENUM保存的是TINYINT，别在枚举中搞一些“中国”“北京”“技术部”这样的字符串，字符串空间又大，效率又低。\n#### 三、小众但有用的SQL实践\n（9）如果明确知道只有一条结果返回，limit 1能够提高效率。\n\n	select * from user where login_name=?\n\n可以优化为：\n\n	select * from user where login_name=? limit 1\n\n原因：\n\n你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动。\n\n（10）把计算放到业务层而不是数据库层，除了节省数据的CPU，还有意想不到的查询缓存优化效果。\n\n	select * from order where date < = CURDATE()\n\n这不是一个好的SQL实践，应该优化为：\n\n	$curDate = date(\'Y-m-d\');\n\n	$res = mysql_query(\'select * from order where date < = $curDate\');\n\n\n\n画外音：不要问我这是什么语言。\n\n原因：释放了数据库的CPU。多次调用，传入的SQL相同，才可以利用查询缓存。\n\n\n\n（11）强制类型转换会全表扫描\n\n	select * from user where phone=13800001234','<div class=blogDetail><h4><a id=\"SQL_0\"></a>一、一些常见的SQL实践</h4>\n<p>（1）负向条件查询不能使用索引。</p>\n<pre><code>select * from order where status!=0 and stauts!=1\n\nnot in/not exists 都不是好习惯。\n</code></pre>\n<p>可以优化为in查询：</p>\n<pre><code>select * from order where status in(2,3)\n</code></pre>\n<p>（2）前导模糊查询不能使用索引。</p>\n<pre><code>select * from order where desc like \'%XX\'\n</code></pre>\n<p>而非前导模糊查询则可以：</p>\n<pre><code>select * from order where desc like \'XX%\'\n</code></pre>\n<p>（3）数据区分度不大的字段不宜使用索引。</p>\n<pre><code>select * from user where sex=1\n</code></pre>\n<p>原因：性别只有男，女，每次过滤掉的数据很少，不宜使用索引。</p>\n<p>经验上，能过滤80%数据时就可以使用索引。对于订单状态，如果状态值很少，不宜使用索引，如果状态值很多，能够过滤大量数据，则应该建立索引。</p>\n<p>（4）在属性上进行计算不能命中索引。</p>\n<pre><code>select * from order where YEAR(date) &lt; = \'2020\'\n</code></pre>\n<p>即使date上建立了索引，也会全表扫描，可优化为值计算：</p>\n<pre><code>select * from order where date &lt; = CURDATE()\n</code></pre>\n<p>或者：</p>\n<pre><code>select * from order where date &lt; = \'2020-01-01\'\n</code></pre>\n<h4><a id=\"SQL_38\"></a>二、并非周知的SQL实践</h4>\n<p>（5）如果业务大部分是单条查询，使用Hash索引性能更好，例如用户中心。</p>\n<pre><code>select * from user where uid=?\n\nselect * from user where login_name=?\n</code></pre>\n<p>原因：</p>\n<pre><code>B-Tree索引的时间复杂度是O(log(n))；\n\nHash索引的时间复杂度是O(1)。\n</code></pre>\n<p>（6）允许为null的列，查询有潜在大坑。</p>\n<p>单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集。</p>\n<pre><code>select * from user where name != \'shenjian\'\n</code></pre>\n<p>如果name允许为null，索引不存储null值，结果集中不会包含这些记录。</p>\n<p>所以，请使用not null约束以及默认值。</p>\n<p>（7）复合索引最左前缀，并不是指SQL语句的where顺序要和复合索引一致。</p>\n<p>用户中心建立了(login_name, passwd)的复合索引</p>\n<pre><code>select * from user where login_name=? and passwd=?\n\nselect * from user where passwd=? and login_name=?\n</code></pre>\n<p>都能够命中索引。</p>\n<pre><code>select * from user where login_name=?\n</code></pre>\n<p>也能命中索引，满足复合索引最左前缀。</p>\n<pre><code>select * from user where passwd=?\n</code></pre>\n<p>不能命中索引，不满足复合索引最左前缀。</p>\n<p>（8）使用ENUM而不是字符串。</p>\n<p>ENUM保存的是TINYINT，别在枚举中搞一些“中国”“北京”“技术部”这样的字符串，字符串空间又大，效率又低。</p>\n<h4><a id=\"SQL_83\"></a>三、小众但有用的SQL实践</h4>\n<p>（9）如果明确知道只有一条结果返回，limit 1能够提高效率。</p>\n<pre><code>select * from user where login_name=?\n</code></pre>\n<p>可以优化为：</p>\n<pre><code>select * from user where login_name=? limit 1\n</code></pre>\n<p>原因：</p>\n<p>你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动。</p>\n<p>（10）把计算放到业务层而不是数据库层，除了节省数据的CPU，还有意想不到的查询缓存优化效果。</p>\n<pre><code>select * from order where date &lt; = CURDATE()\n</code></pre>\n<p>这不是一个好的SQL实践，应该优化为：</p>\n<pre><code>$curDate = date(\'Y-m-d\');\n\n$res = mysql_query(\'select * from order where date &lt; = $curDate\');\n</code></pre>\n<p>画外音：不要问我这是什么语言。</p>\n<p>原因：释放了数据库的CPU。多次调用，传入的SQL相同，才可以利用查询缓存。</p>\n<p>（11）强制类型转换会全表扫描</p>\n<pre><code>select * from user where phone=13800001234</code></pre>\n</div>','2020-06-21',4,1);

/*Table structure for table `data` */

CREATE TABLE `data` (
  `name` varchar(30) NOT NULL,
  `work` varchar(30) DEFAULT NULL,
  `address` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,
  `qq` varchar(30) DEFAULT NULL,
  `wechar` varchar(30) DEFAULT NULL,
  `github` varchar(30) DEFAULT NULL,
  `email` varchar(30) DEFAULT NULL,
  PRIMARY KEY (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `data` */

insert  into `data`(`name`,`work`,`address`,`qq`,`wechar`,`github`,`email`) values ('Guo','学生','南京','123456789','guo904004593','Gxy2020','904004593@qq.com');

/*Table structure for table `demo` */

CREATE TABLE `demo` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `markdown` longtext,
  `html` longtext,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `demo` */

insert  into `demo`(`id`,`markdown`,`html`) values (1,'::: hljs-center\n\n# Vue的使用\n\n:::\n\n1. markdown富文本编辑器\n2. 组件的注册\n3. svg图片的使用','<div class=\"hljs-center\">\n<h1><a id=\"Vue_2\"></a>Vue的使用</h1>\n</div>\n<ol>\n<li>markdown富文本编辑器</li>\n<li>组件的注册</li>\n<li>svg图片的使用</li>\n</ol>');

/*Table structure for table `lab` */

CREATE TABLE `lab` (
  `labId` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  PRIMARY KEY (`labId`,`name`)
) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `lab` */

insert  into `lab`(`labId`,`name`) values (1,'java');
insert  into `lab`(`labId`,`name`) values (2,'Vue');
insert  into `lab`(`labId`,`name`) values (4,'mysql');
insert  into `lab`(`labId`,`name`) values (5,'Redis');
insert  into `lab`(`labId`,`name`) values (9,'JavaScript');

/*Table structure for table `msg` */

CREATE TABLE `msg` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(30) NOT NULL,
  `email` varchar(30) NOT NULL,
  `content` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `time` varchar(30) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `msg` */

insert  into `msg`(`id`,`name`,`email`,`content`,`time`) values (1,'G','904004593@qq.com','我来留言了','2020-06-22');
insert  into `msg`(`id`,`name`,`email`,`content`,`time`) values (2,'Guo','123456@qq.com','加油呀','2020-06-22 13:58');

/*Table structure for table `sys_user` */

CREATE TABLE `sys_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '管理员',
  `username` varchar(18) NOT NULL,
  `password` varchar(18) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `sys_user` */

insert  into `sys_user`(`id`,`username`,`password`) values (1,'admin','admin');

/*Table structure for table `userlog` */

CREATE TABLE `userlog` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(18) NOT NULL COMMENT '用户',
  `time` varchar(30) NOT NULL COMMENT '时间',
  `ip` varchar(24) NOT NULL COMMENT 'ip',
  `city` varchar(30) DEFAULT NULL COMMENT '城市',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `userlog` */

insert  into `userlog`(`id`,`username`,`time`,`ip`,`city`) values (2,'admin','2020-06-11 09:02','127.0.0.1','中国-南京');
insert  into `userlog`(`id`,`username`,`time`,`ip`,`city`) values (3,'admin','2020-06-11 09:19','127.0.0.1','中国-南京');
insert  into `userlog`(`id`,`username`,`time`,`ip`,`city`) values (5,'admin','2020-06-25 23:57','127.0.0.1','中国-南京');
insert  into `userlog`(`id`,`username`,`time`,`ip`,`city`) values (15,'admin','2020-06-27 23:19','127.0.0.1','中国-南京');
insert  into `userlog`(`id`,`username`,`time`,`ip`,`city`) values (17,'admin','2020-06-27 23:20','127.0.0.1','中国-南京');
insert  into `userlog`(`id`,`username`,`time`,`ip`,`city`) values (18,'admin','2020-06-27 23:20','127.0.0.1','中国-南京');
insert  into `userlog`(`id`,`username`,`time`,`ip`,`city`) values (19,'admin','2020-06-27 23:24','127.0.0.1','中国-南京');
insert  into `userlog`(`id`,`username`,`time`,`ip`,`city`) values (20,'admin','2020-06-27 23:37','127.0.0.1','中国-南京');
insert  into `userlog`(`id`,`username`,`time`,`ip`,`city`) values (23,'admin','2020-06-28 00:23','10.30.164.144','中国-南京');
insert  into `userlog`(`id`,`username`,`time`,`ip`,`city`) values (24,'admin','2020-06-28 00:53','10.30.164.144','中国-南京');
insert  into `userlog`(`id`,`username`,`time`,`ip`,`city`) values (25,'admin','2020-07-05 19:06','192.168.1.9','中国-南京');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
